# -*- coding: utf-8 -*-
"""Flickr webapp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EGpgPW84i8d45Ok9PijmJflcDzK1vFkU
"""


import pickle, cv2
import numpy as np
import keras.models as km
import matplotlib.pyplot as plt
import os

maindir='.'



def normalize_image(img, target_size):
    
    # for debugging only
    #cv2.imshow("Original image", img)
    #print('Oringinal image dimensions =', img.shape)
    
    # resize
    scale_x = target_size[0]/img.shape[0]
    scale_y = target_size[1]/img.shape[1]
    scale = min(scale_x, scale_y, 1)
    
    width = int(img.shape[1] * scale)
    height = int(img.shape[0] * scale)
    dim = (width, height)
    
    resized = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)
    
    # for debugging only
    #print('Resized Dimensions : ',resized.shape)
    #cv2.imshow("Resized image", resized)
    
    # zeropad
    x_before = round((target_size[0]-resized.shape[0])/2+0.1)
    x_after = round((target_size[0]-resized.shape[0])/2-0.1)
    y_before = round((target_size[1]-resized.shape[1])/2+0.1)
    y_after = round((target_size[1]-resized.shape[1])/2-0.1)
    
    padded = np.pad(resized,((x_before,x_after),(y_before,y_after),(0,0)),'constant', constant_values=0)
    
    # for debugging only
    #print('Padded Dimensions : ',padded.shape)
    #cv2.imshow("Padded image", padded)
    
    return(padded)

def get_lables(image,uploadfolder='.'):
    image_shape=(128,128,3)
    print('Loading data')
    with open(maindir+'/robust_covs.dat','rb') as f:
        robust_covs=pickle.load(f)
    with open(maindir+'/lv_train.dat','rb') as f:
        lv_train=pickle.load(f)
    with open(maindir+'/labels.dat','rb') as f:
        labels=pickle.load(f)
    with open(maindir+'/pca.dat','rb') as f:
        pca=pickle.load(f)
    with open(maindir+'/y_train.dat','rb') as f:
        y_train=pickle.load(f)
    
    print('Normalizing image')
    img = cv2.imread(image, cv2.IMREAD_UNCHANGED)
    normalized = normalize_image(img, image_shape)
    x = np.expand_dims(normalized,axis=0)
    x = np.float32(x)/255.0
    
    print('Encoding')
    encoder = km.load_model(maindir+'/vae2_encoder.h5')
    lv_x = encoder.predict(x)[2]
    lv_x_pca = pca.transform(lv_x)
    
    print('Predicting')
    nclass=len(labels)
    d_robust = np.zeros(nclass)
    for i in range(nclass):
        d_robust[i] = robust_covs[i].mahalanobis(lv_x_pca)
        
    #predicted_class = np.argmin(d_robust,axis=-1)
    predicted_labels = np.argsort(d_robust,axis=-1)[:3]
    
    top3 = [labels[i] for i in predicted_labels]
    
    # plot class centroids and dispersions in the PCA domain
    print('Generating PCA plot')
    uploadfolder = os.path.abspath(uploadfolder)

    import time
    timestr = time.strftime("%Y%m%d-%H%M%S")
    plotfilename='latent_space'+timestr+'.jpg'
    plotfile = uploadfolder+'/'+plotfilename

    def normalize_to01(x):
        minimum = np.min(x)
        maximum = np.max(x)
        return((x-minimum)/(maximum-minimum))
    
    lv_train_pca = pca.transform(lv_train)
    mean_class = np.zeros((nclass,lv_train_pca.shape[1]))
    dispersion_class = np.zeros(nclass)
    
    for i in range(nclass):
        mean_class[i,:] = np.mean(lv_train_pca[y_train==i,],axis=0)
        dispersion_class[i]=np.mean(robust_covs[i].mahalanobis(lv_train_pca[y_train==i,]))
    
    dispersion_class = normalize_to01(dispersion_class)
    plt.figure()
    for i in range(nclass):
        plt.scatter(mean_class[i,0],mean_class[i,1], label=str(labels[i]), s=(20+dispersion_class[i]*20)**2, alpha=0.5)
        plt.annotate(str(labels[i]),(mean_class[i,0],mean_class[i,1]))
    plt.scatter(lv_x_pca[0,0],lv_x_pca[0,1], c='red',marker='x',alpha=1)
    plt.annotate('Input Image',(lv_x_pca[0,0],lv_x_pca[0,1]))
    
    plt.xlabel('PC1 ('+str(int(pca.explained_variance_ratio_[0]*100))+'% variance explained)')
    plt.ylabel('PC2 ('+str(int(pca.explained_variance_ratio_[1]*100))+'% variance explained)')
    plt.savefig(plotfile)
    #plt.show()



    return(top3,plotfilename)